#!/usr/bin/env simrun

  Copyright (C) 2020 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

#
  This is a very basic implementation of a scramble like video game to be played
  on a character console.

  https://en.wikipedia.org/wiki/Scramble_(video_game)

  This is by purpose only a skeleton of the game - waiting for *you* to develop
  it into a full fledged action game!

# dynamic content types

$LASER_BEAM .

$type_of (!) # used for dynamic contents
$x_of (!) # used for dynamic contents
$y1_of (!) # used for dynamic contents
$y2_of (!) # used for dynamic contents

$WIDTH 80 # the width of the cave in character columns
$HEIGHT 50 # the height of the cave in half character rows

#
  The height of a character is approximately about twice the size of its width.

  So we use half-blocks to accommodate for this inbalance.

$full_block '@0x2588;'
$upper_half_block '@0x2580;'
$lower_half_block '@0x2584;'
$spaceship_head '@0x2326;'
$spaceship_tail '@0x2327;'
$cannon '@0x25e2;'
$star '@0x2726;'
$mine '@0x2738;'
$single_vertical_bar '@0x2502;'
$double_vertical_bar '@0x2551;'

$BLACK     '@0x000000;'
$WHITE     '@0xffffff;'
$GREY      '@0x808080;'
$DARK_GREY '@0x202020;'
$RED       '@0xff0000;'
$GREEN     '@0x00ff00;'
$BLUE      '@0x0000ff;'
$YELLOW    '@0xffff00;'
$ORANGE    '@0xff8000;'
$SKY_BLUE   '@0xc0c0ff;'

$star_colour GREEN
$mine_colour DARK_GREY
$spaceship_colour BLUE
$beam_colour YELLOW
$beam_cannon_colour ORANGE
$cannon_colour RED

$$dynamic_contents empty_list

$draw_vertical_bar:
  #
    draws a vertical stack of block graphics characters

    *x* is the character column where to draw the bar

    *top_y* and *bottom_y* are measured in half rows!
  (
    x
    top_y
    bottom_y
  )
  $$y (top_y+1) >> 1 # in rows
  if top_y.is_even:
    set_text_colour_at x y BLACK
    set_character_at x y lower_half_block
    inc &y
  repeat (bottom_y >> 1) - (top_y >> 1):
    set_text_colour_at x y BLACK
    set_character_at x y full_block
    inc &y
  if bottom_y.is_odd:
    set_text_colour_at x y BLACK
    set_character_at x y upper_half_block

$$prev_floor_y undefined

$draw_cave_column:
  #
    draws a new column of the cave
  (
    x # the column number on the screen
  )
  inc &cave_draw_x

  draw_vertical_bar x 1 ceiling_y # draw the ceiling
  draw_vertical_bar x floor_y HEIGHT # draw the floor

  # add dynamic content

  $y1 (ceiling_y+1 .div. 2) + 1
  $y2 (floor_y-1 .div. 2)

  cond
    -> cave_draw_x > 400 && next(&rng 20) == 14 && prev_floor_y >= floor_y:
      set_text_colour_at x y2+1 cannon_colour
      set_character_at x y2+1 cannon
    -> cave_draw_x > 300 && cave_draw_x <= 400 && next(&rng 40) == 1:
      set_text_colour_at x y1-1 beam_cannon_colour
      set_character_at x y1-1 double_vertical_bar

      set_text_colour_at x y2+1 beam_cannon_colour
      set_character_at x y2+1 double_vertical_bar

      push &dynamic_contents
	types::object
	  .type_of LASER_BEAM
	  .x_of cave_draw_x
	  .y1_of y1
	  .y2_of y2
    -> cave_draw_x > 200 && next(&rng 12) == 1:
      $mine_y next(&rng y1..y2)
      set_text_colour_at x mine_y mine_colour
      set_character_at x mine_y mine
    -> cave_draw_x > 100 && next(&rng 12) == 1:
      $star_y next(&rng y1..y2)
      set_text_colour_at x star_y star_colour
      set_character_at x star_y star

  !prev_floor_y floor_y

  # update the ceiling height

  !ceiling_y ceiling_y+next(&rng 5)-3 # make a random change
  extend_to &ceiling_y 1 # not too high
  reduce_to &ceiling_y 35 # not too low

  # update the floor height

  !floor_y floor_y+next(&rng 5)-3 # make a random change
  reduce_to &floor_y HEIGHT # not too low
  extend_to &floor_y 16 # not too high

  # check whether the cave would be too narrow

  $cave_height floor_y-ceiling_y # the height of the cave
  if cave_height < 15: # too narrow?
    $delta (15-cave_height) .div. 2 # how much?
    minus &ceiling_y delta # distribute the change to ceiling ...
    plus &floor_y delta # ... and floor

$$rng mersenne_twister(4711)
  #
    our pseudo random number generator

    To change the cave just change the seed value.

# initialize the ceiling and floor coordinates of the cave

$$ceiling_y next(&rng 21)
  #
    the height of the cave's ceiling - initialized with a random value

$$floor_y HEIGHT+1-next(&rng 21)
  #
    the height of the cave's floor - initialized with a random value

$$spaceship_x 1
  #
    the horizontal position (column) of the spaceship

    We start in the leftmost column of the screen.

$$spaceship_y 13
  #
    the vertical position (row) of the spaceship

    We start in the middle of the screen.

$$cave_length 600
  #
    the total length of the cave

$$cave_draw_x 0
  #
    the current drawing position of the cave

$$cave_start_x 0
  #
    the current display start position of the cave

$draw_dynamic_contents:
  for_each dynamic_contents: (item)
    case type_of(item)
      LASER_BEAM:
	if (cave_start_x .mod. 20) >= 15:
	  $x x_of(item)-cave_start_x
	  from_to y1_of(item) y2_of(item): (y)
	    set_text_colour_at x y beam_colour
	    set_character_at x y single_vertical_bar

$undraw_dynamic_contents:
  for_each dynamic_contents: (item)
    case type_of(item)
      LASER_BEAM:
	if (cave_start_x .mod. 20) >= 15:
	  $x x_of(item)-cave_start_x
	  from_to y1_of(item) y2_of(item): (y)
	    set_character_at x y ' '

$update_dynamic_contents:
  update_each &dynamic_contents: (&item)
    if x_of(item)-cave_start_x < 1:
      !item undefined # the item is no longer visible - delete it

$$original_background_colours undefined

$draw_spaceship
  #
    draws the spaceship
  :
    set_text_colour_at spaceship_x spaceship_y spaceship_colour
    set_text_colour_at spaceship_x+1 spaceship_y spaceship_colour
    set_character_at spaceship_x spaceship_y spaceship_tail
    set_character_at spaceship_x+1 spaceship_y spaceship_head

    # draw cone of light

    $RX 20
    $RY 5

    $cx spaceship_x
    $cy spaceship_y

    $min_x cx
    $max_x min(cx+RX WIDTH)
    $min_y max(cy-RY 1)
    $max_y min(cy+RY HEIGHT)

    !original_background_colours empty_list
    from_to min_y max_y: (y)
      $$background_colour_line empty_list
      from_to min_x max_x: (x)
	$background_colour background_colour_at(x y)
	push &background_colour_line background_colour
	$dx x-cx
	$dy 2*(y-cy)
	if dx >= 2*abs(dy):
	  $distance min(sqrt(dx*dx+dy*dy) RX)
	  $lighting_colour
	    colour_mixture
	      GREY = RX-distance
	      background_colour = distance
	  set_background_colour_at x y lighting_colour
      push &original_background_colours background_colour_line

$undraw_spaceship
  #
    "undraws" the spaceship
  :
    set_character_at spaceship_x spaceship_y ' '
    set_character_at spaceship_x+1 spaceship_y ' '

    $RX 20
    $RY 5

    $cx spaceship_x
    $cy spaceship_y

    $min_x cx
    $max_x min(cx+RX WIDTH)
    $min_y max(cy-RY 1)
    $max_y min(cy+RY HEIGHT)

    from_to min_y max_y: (y)
      $$background_colour_line original_background_colours(y-min_y+1)
      from_to min_x max_x: (x)
	set_background_colour_at x y background_colour_line(x-min_x+1)

$draw_message
  #
    draws a message in the center of the screen
  :
    (
      msg # the message to draw
    )
    $len length_of(msg)
    at div((80-len) 2)+1 13
    set_text_colour BLACK
    set_background_colour WHITE
    draw_text msg

$check_for_collision:
  #
    checks whether the spaceship hit any obstacle

  $check: (x y)
    $chr character_at(x y)
    if chr != ' ':
      $$msg "crashed into the walls of the cave"
      case chr
	star: !msg "hit a floating star"
	mine: !msg "hit a mine"
	single_vertical_bar: !msg "was hit by a laser beam"
	double_vertical_bar: !msg "crashed into a laser beamer"
	cannon: !msg "crashed into a cannon"

      draw_message "Your ship @(msg)!"
      update_terminal # make all updates visible
      sleep 3 # wait for 3 seconds ...
      terminate # and quit the game

  check spaceship_x+1 spaceship_y
  check spaceship_x spaceship_y

initialize_terminal BLACK DARK_GREY
  # must be called before any other terminal function

#
  We check for the standard terminal size.

  The cave would be different for other resolutions and results (highscores!)
  could not be compared.

if width_of(current_screen) != 80 || height_of(current_screen) != 25:
  Error "Please change your terminal size to 80x25!"

do: # initialize the terminal
  get_terminal_attributes STDIN_FILENO $$attributes
  use_canonical_mode &attributes false # we want no line-buffering ...
  echo_characters &attributes false # ... and no echoing of typed in characters
  unless set_terminal_attributes(STDIN_FILENO attributes):
    Error "Failed to disable canonical input mode!"
  cursor_off # ... and we want no blinking cursor!

at_exit:
  #
    clean the screen and restore all changes we made to input buffering and
    echoing

  restore_colours
  clear_screen
  cursor_on

  # empty the input queue
  wait_to $event READ_FROM=STDIN_FILENO TIMEOUT=0
  case std::type_of(event)
    READ_FROM: # we got a keystroke
      read_from STDIN_FILENO $dummy

  get_terminal_attributes STDIN_FILENO $$attributes
  use_canonical_mode &attributes false
  echo_characters &attributes true
  unless set_terminal_attributes(STDIN_FILENO attributes):
    Error "Failed to reset input mode!"

# draw the initial view of the cave

from_to 1 WIDTH: (x) draw_cave_column x # fill all columns of the screen
draw_spaceship # draw the spaceship
update_terminal # make all updates visible
undraw_spaceship

# event loop

$$t current_time()

do: (-> break)
  do_until:
    plus &t 0.08
    $timeout t-current_time()
    wait_to $event READ_FROM=STDIN_FILENO TIMEOUT=timeout
      # we wait for a keystroke or until some time elapsed

    $$input_buffer ""
    case std::type_of(event)
      READ_FROM: # we got a keystroke
	read_from STDIN_FILENO !input_buffer
	sleep t-current_time()

    unless input_buffer.is_empty: # are there keys in the backlog buffer?
      case get(&input_buffer)
	'w', 'j':
	  dec &spaceship_y # move the spaceship upwards
	's', 'n':
	  inc &spaceship_y # move the spaceship downwards
	'a', 'v':
	  if spaceship_x > 1:
	    dec &spaceship_x # move the spaceship backwards
	'd', 'b':
	  if spaceship_x < WIDTH:
	    inc &spaceship_x # move the spaceship forwards
	'q': break # the user wants to quit the game

    # update the view of the cave

    inc &cave_start_x

    $distance_to_exit cave_length-cave_draw_x
    if
      distance_to_exit >= 0:
	if
	  distance_to_exit > 100:
	    set_background_colour DARK_GREY
	  :
	    $a distance_to_exit
	    $b 100-a
	    set_background_colour colour_mixture(DARK_GREY = a SKY_BLUE = b)
      :
	set_background_colour SKY_BLUE
    scroll_left # scroll the whole cave left by 1 character column

    set_background_colour undefined

    if
      cave_draw_x <= cave_length:
	draw_cave_column 80 # draw a new right-most character column
      :
	inc &cave_draw_x

    draw_dynamic_contents

    check_for_collision

    draw_spaceship # draw the spaceship

    update_terminal # make all updates visible

    undraw_dynamic_contents
    undraw_spaceship # "undraw" the spaceship

    update_dynamic_contents

    -> cave_draw_x+spaceship_x > cave_length+WIDTH

  draw_message "You survived!"
  update_terminal
  sleep 3
